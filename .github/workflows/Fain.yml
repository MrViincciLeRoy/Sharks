name: Complete Database Reset (Chunked Drop)

on:
  workflow_dispatch:
    inputs:
      confirm_reset:
        description: 'Type "RESET" to confirm complete wipe'
        required: true
        default: ''

jobs:
  complete-reset:
    runs-on: ubuntu-latest
    
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirm_reset }}" != "RESET" ]; then
            echo "‚ùå Confirmation failed. You must type 'RESET' to proceed."
            exit 1
          fi
          echo "‚úÖ Confirmation received. Proceeding with complete reset..."

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Drop database objects in chunks
        env:
          PGHOST: ${{ secrets.PGHOST }}
          PGPORT: ${{ secrets.PGPORT }}
          PGUSER: ${{ secrets.PGUSER }}
          PGPASSWORD: ${{ secrets.PGPASSWORD }}
          PGDATABASE: ${{ secrets.PGDATABASE }}
          PGSSLMODE: require
        run: |
          echo "üóëÔ∏è  Dropping all objects from database: ${PGDATABASE}"
          echo "Using chunked approach to avoid memory limits..."
          
          # Drop objects in multiple passes to avoid memory issues
          for PASS in 1 2 3 4 5; do
            echo ""
            echo "=== Pass ${PASS} ==="
            
            PGPASSWORD="${PGPASSWORD}" psql -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}" -d "${PGDATABASE}" << 'EOF'
          DO $$ 
          DECLARE
              r RECORD;
              dropped_count INT := 0;
          BEGIN
              -- Drop views first (they depend on tables)
              FOR r IN (
                  SELECT table_name 
                  FROM information_schema.views 
                  WHERE table_schema = 'public'
                  LIMIT 50
              )
              LOOP
                  BEGIN
                      EXECUTE 'DROP VIEW IF EXISTS public.' || quote_ident(r.table_name) || ' CASCADE';
                      dropped_count := dropped_count + 1;
                  EXCEPTION WHEN OTHERS THEN
                      RAISE NOTICE 'Error dropping view %: %', r.table_name, SQLERRM;
                  END;
              END LOOP;
              
              -- Drop materialized views
              FOR r IN (
                  SELECT matviewname 
                  FROM pg_matviews 
                  WHERE schemaname = 'public'
                  LIMIT 50
              )
              LOOP
                  BEGIN
                      EXECUTE 'DROP MATERIALIZED VIEW IF EXISTS public.' || quote_ident(r.matviewname) || ' CASCADE';
                      dropped_count := dropped_count + 1;
                  EXCEPTION WHEN OTHERS THEN
                      RAISE NOTICE 'Error dropping materialized view %: %', r.matviewname, SQLERRM;
                  END;
              END LOOP;
              
              -- Drop tables in chunks
              FOR r IN (
                  SELECT tablename 
                  FROM pg_tables 
                  WHERE schemaname = 'public'
                  LIMIT 100
              ) 
              LOOP
                  BEGIN
                      EXECUTE 'DROP TABLE IF EXISTS public.' || quote_ident(r.tablename) || ' CASCADE';
                      dropped_count := dropped_count + 1;
                  EXCEPTION WHEN OTHERS THEN
                      RAISE NOTICE 'Error dropping table %: %', r.tablename, SQLERRM;
                  END;
              END LOOP;
              
              RAISE NOTICE '‚úÖ Pass complete - dropped % objects', dropped_count;
          END $$;
          EOF
            
            # Check if we're done
            REMAINING=$(PGPASSWORD="${PGPASSWORD}" psql -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}" -d "${PGDATABASE}" -tAc \
              "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
            
            echo "Tables remaining: ${REMAINING}"
            
            if [ "$REMAINING" -eq "0" ]; then
              echo "‚úÖ All tables dropped!"
              break
            fi
            
            # Small delay between passes
            sleep 2
          done

      - name: Clean up remaining objects
        env:
          PGHOST: ${{ secrets.PGHOST }}
          PGPORT: ${{ secrets.PGPORT }}
          PGUSER: ${{ secrets.PGUSER }}
          PGPASSWORD: ${{ secrets.PGPASSWORD }}
          PGDATABASE: ${{ secrets.PGDATABASE }}
          PGSSLMODE: require
        run: |
          echo "üßπ Cleaning up sequences, functions, and types..."
          
          PGPASSWORD="${PGPASSWORD}" psql -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}" -d "${PGDATABASE}" << 'EOF'
          DO $$ 
          DECLARE
              r RECORD;
          BEGIN
              -- Drop all sequences
              FOR r IN (
                  SELECT sequence_name 
                  FROM information_schema.sequences 
                  WHERE sequence_schema = 'public'
              )
              LOOP
                  BEGIN
                      EXECUTE 'DROP SEQUENCE IF EXISTS public.' || quote_ident(r.sequence_name) || ' CASCADE';
                  EXCEPTION WHEN OTHERS THEN
                      RAISE NOTICE 'Error dropping sequence %: %', r.sequence_name, SQLERRM;
                  END;
              END LOOP;
              
              -- Drop all functions
              FOR r IN (
                  SELECT proname, 
                         oidvectortypes(proargtypes) as argtypes
                  FROM pg_proc 
                  INNER JOIN pg_namespace ns ON (pg_proc.pronamespace = ns.oid)
                  WHERE ns.nspname = 'public'
              )
              LOOP
                  BEGIN
                      EXECUTE 'DROP FUNCTION IF EXISTS public.' || quote_ident(r.proname) || 
                              '(' || r.argtypes || ') CASCADE';
                  EXCEPTION WHEN OTHERS THEN
                      RAISE NOTICE 'Error dropping function %: %', r.proname, SQLERRM;
                  END;
              END LOOP;
              
              -- Drop all custom types
              FOR r IN (
                  SELECT typname
                  FROM pg_type
                  WHERE typnamespace = 'public'::regnamespace
                    AND typtype = 'c'
              )
              LOOP
                  BEGIN
                      EXECUTE 'DROP TYPE IF EXISTS public.' || quote_ident(r.typname) || ' CASCADE';
                  EXCEPTION WHEN OTHERS THEN
                      RAISE NOTICE 'Error dropping type %: %', r.typname, SQLERRM;
                  END;
              END LOOP;
              
              RAISE NOTICE '‚úÖ Cleanup complete';
          END $$;
          EOF

      - name: Verify database is empty
        env:
          PGHOST: ${{ secrets.PGHOST }}
          PGPORT: ${{ secrets.PGPORT }}
          PGUSER: ${{ secrets.PGUSER }}
          PGPASSWORD: ${{ secrets.PGPASSWORD }}
          PGDATABASE: ${{ secrets.PGDATABASE }}
          PGSSLMODE: require
        run: |
          echo "üîç Verifying database is empty..."
          
          TABLE_COUNT=$(PGPASSWORD="${PGPASSWORD}" psql -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}" -d "${PGDATABASE}" -tAc \
            "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
          
          VIEW_COUNT=$(PGPASSWORD="${PGPASSWORD}" psql -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}" -d "${PGDATABASE}" -tAc \
            "SELECT COUNT(*) FROM information_schema.views WHERE table_schema = 'public';")
          
          SEQ_COUNT=$(PGPASSWORD="${PGPASSWORD}" psql -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}" -d "${PGDATABASE}" -tAc \
            "SELECT COUNT(*) FROM information_schema.sequences WHERE sequence_schema = 'public';")
          
          echo "üìä Database status:"
          echo "  - Tables: ${TABLE_COUNT}"
          echo "  - Views: ${VIEW_COUNT}"
          echo "  - Sequences: ${SEQ_COUNT}"
          
          if [ "$TABLE_COUNT" -eq "0" ] && [ "$VIEW_COUNT" -eq "0" ]; then
            echo "‚úÖ Database is clean!"
          else
            echo "‚ö†Ô∏è Warning: Some objects still exist, but proceeding with init..."
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build initialization Docker image
        run: |
          echo "üèóÔ∏è  Building Docker image..."
          docker build -f Dockerfile.init -t odoo-init .

      - name: Initialize Fresh Odoo Database
        env:
          PGHOST: ${{ secrets.PGHOST }}
          PGPORT: ${{ secrets.PGPORT }}
          PGUSER: ${{ secrets.PGUSER }}
          PGPASSWORD: ${{ secrets.PGPASSWORD }}
          PGDATABASE: ${{ secrets.PGDATABASE }}
          PGSSLMODE: require
        run: |
          echo "üöÄ Installing Odoo with all modules..."
          docker run --rm \
            -e PGHOST="${PGHOST}" \
            -e PGPORT="${PGPORT}" \
            -e PGUSER="${PGUSER}" \
            -e PGPASSWORD="${PGPASSWORD}" \
            -e PGDATABASE="${PGDATABASE}" \
            -e PGSSLMODE="${PGSSLMODE}" \
            odoo-init

      - name: Reset Complete
        run: |
          echo "‚úÖ Complete database reset finished!"
          echo ""
          echo "üì¶ Installed modules:"
          echo "  ‚Ä¢ base"
          echo "  ‚Ä¢ account"
          echo "  ‚Ä¢ GMailer"
          echo "  ‚Ä¢ erpnext_connector"
          echo "  ‚Ä¢ gmail_erpnext_bridge"
          echo ""
          echo "üîê Default credentials:"
          echo "  Username: admin"
          echo "  Password: admin"
          echo ""
          echo "üéâ Your Odoo database is ready!"
